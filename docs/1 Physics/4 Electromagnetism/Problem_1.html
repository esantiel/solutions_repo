<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Lorentz Force Simulation</title>
    <style>
        canvas { border: 1px solid black; }
        body { font-family: Arial, sans-serif; margin: 20px; }
        .controls { margin: 10px 0; }
    </style>
</head>
<body>
    <h1>Lorentz Force Simulation</h1>
    <canvas id="simulationCanvas" width="600" height="600"></canvas>
    <div class="controls">
        <label for="scenario">Scenario: </label>
        <select id="scenario" onchange="resetSimulation()">
            <option value="uniformB">Uniform Magnetic Field</option>
            <option value="combinedEB">Combined E and B Fields</option>
            <option value="crossedEB">Crossed E and B Fields</option>
        </select><br>
        <label for="bStrength">Magnetic Field Strength (T): </label>
        <input type="range" id="bStrength" min="0.5" max="2" step="0.1" value="1" oninput="resetSimulation()"><br>
        <label for="eStrength">Electric Field Strength (V/m): </label>
        <input type="range" id="eStrength" min="0" max="200000" step="10000" value="100000" oninput="resetSimulation()"><br>
        <button onclick="resetSimulation()">Reset Simulation</button>
    </div>

    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        // Constants
        const q = 1.6e-19;  // Charge (Coulombs, electron)
        const m = 9.11e-31; // Mass (kg, electron)
        const dt = 1e-9;    // Time step (seconds)
        const scale = 1e9;  // Scale factor for visualization

        // Vector3D class
        class Vector3D {
            constructor(x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
            }
            add(v) { return new Vector3D(this.x + v.x, this.y + v.y, this.z + v.z); }
            scale(s) { return new Vector3D(this.x * s, this.y * s, this.z * s); }
            cross(v) {
                return new Vector3D(
                    this.y * v.z - this.z * v.y,
                    this.z * v.x - this.x * v.z,
                    this.x * v.y - this.y * v.x
                );
            }
        }

        // Lorentz force: F = q(E + v x B)
        function lorentzForce(v, E, B) {
            const vCrossB = v.cross(B);
            return E.add(vCrossB).scale(q);
        }

        // RK4 integration
        function rk4Step(r, v, E, B, dt) {
            const k1_v = lorentzForce(v, E, B).scale(1 / m);
            const k1_r = v;

            const v2 = v.add(k1_v.scale(dt / 2));
            const k2_v = lorentzForce(v2, E, B).scale(1 / m);
            const k2_r = v2;

            const v3 = v.add(k2_v.scale(dt / 2));
            const k3_v = lorentzForce(v3, E, B).scale(1 / m);
            const k3_r = v3;

            const v4 = v.add(k3_v.scale(dt));
            const k4_v = lorentzForce(v4, E, B).scale(1 / m);
            const k4_r = v4;

            const r_new = r.add(k1_r.add(k2_r.scale(2)).add(k3_r.scale(2)).add(k4_r).scale(dt / 6));
            const v_new = v.add(k1_v.add(k2_v.scale(2)).add(k3_v.scale(2)).add(k4_v).scale(dt / 6));

            return { r: r_new, v: v_new };
        }

        // Simulation state
        let r = new Vector3D(0, 0, 0);          // Initial position
        let v = new Vector3D(1e5, 0, 0);        // Initial velocity (m/s)
        let trajectory = [];
        let step = 0;
        const maxSteps = 1000;

        // Field configurations
        function getFields() {
            const scenario = document.getElementById('scenario').value;
            const bStrength = parseFloat(document.getElementById('bStrength').value);
            const eStrength = parseFloat(document.getElementById('eStrength').value);

            let E, B;
            switch (scenario) {
                case 'uniformB':
                    E = new Vector3D(0, 0, 0);
                    B = new Vector3D(0, 0, bStrength); // B along z
                    break;
                case 'combinedEB':
                    E = new Vector3D(eStrength, 0, 0); // E along x
                    B = new Vector3D(0, 0, bStrength); // B along z
                    break;
                case 'crossedEB':
                    E = new Vector3D(0, eStrength, 0); // E along y
                    B = new Vector3D(0, 0, bStrength); // B along z
                    break;
            }
            return { E, B };
        }

        // Reset simulation
        function resetSimulation() {
            r = new Vector3D(0, 0, 0);
            v = new Vector3D(1e5, 0, 0);
            trajectory = [];
            step = 0;
            ctx.clearRect(0, 0, width, height);
            animate();
        }

        // Animation loop
        function animate() {
            if (step < maxSteps) {
                const { E, B } = getFields();
                const { r: r_new, v: v_new } = rk4Step(r, v, E, B, dt);
                r = r_new;
                v = v_new;
                trajectory.push(r);

                // Draw trajectory (projected to xy-plane)
                ctx.beginPath();
                ctx.strokeStyle = 'blue';
                for (let i = 0; i < trajectory.length; i++) {
                    const x = width / 2 + trajectory[i].x * scale;
                    const y = height / 2 - trajectory[i].y * scale; // Invert y for canvas
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                step++;
                requestAnimationFrame(animate);
            }
        }

        // Start simulation
        resetSimulation();
    </script>
</body>
</html>